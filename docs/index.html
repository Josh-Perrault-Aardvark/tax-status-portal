<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>Tax Return Status</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <style>
      body {
        font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI",
          sans-serif;
        background: #ffffff;
        color: #0f172a;
        margin: 0;
      }
      .page {
        max-width: 960px;
        margin: 0 auto;
        padding: 32px 24px;
      }
      h1 {
        font-size: 24px;
        margin: 0 0 16px;
      }
      .alert {
        padding: 12px 16px;
        border-radius: 6px;
        border: 1px solid #fecaca;
        background: #fef2f2;
        color: #b91c1c;
        font-size: 14px;
        margin-bottom: 16px;
      }
      .table-wrapper {
        border: 1px solid #e2e8f0;
        border-radius: 8px;
        overflow-x: auto;
      }
      table {
        width: 100%;
        border-collapse: collapse;
        font-size: 14px;
      }
      thead {
        background: #f1f5f9;
      }
      th,
      td {
        padding: 12px 16px;
        text-align: left;
      }
      th {
        font-size: 12px;
        font-weight: 600;
        color: #475569;
      }
      th.sortable {
        cursor: pointer;
      }
      tbody tr:nth-child(odd) {
        background: #ffffff;
      }
      tbody tr:nth-child(even) {
        background: #f8fafc;
      }
      tbody tr + tr {
        border-top: 1px solid #e2e8f0;
      }
      td.client {
        font-weight: 500;
      }
      td.empty {
        text-align: center;
        color: #6b7280;
      }
    </style>
  </head>
  <body>
    <main class="page">
      <header>
        <h1>Tax Return Status</h1>
      </header>

      <div id="error" class="alert" style="display: none"></div>

      <section>
        <div class="table-wrapper">
          <table>
            <thead>
              <tr>
                <th class="sortable" data-sort="clientName">Client</th>
                <th class="sortable" data-sort="taxYear">Tax Year</th>
                <th class="sortable" data-sort="taxReturnType">
                  Tax Return Type
                </th>
                <th class="sortable" data-sort="status">Status</th>
                <th class="sortable" data-sort="lastUpdatedIso">
                  Last Updated
                </th>
              </tr>
            </thead>
            <tbody id="rows"></tbody>
          </table>
        </div>
      </section>
    </main>

    <script>
      // ---------------------------
      // Read ?tickets=... from URL
      // ---------------------------
      function getRawFromQuery() {
        const params = new URLSearchParams(window.location.search);
        const encoded = params.get("tickets");
        if (!encoded) return "";
        try {
          return decodeURIComponent(encoded);
        } catch {
          return encoded;
        }
      }

      // ---------------------------
      // Map raw internal statuses → client-facing labels
      // ---------------------------
      function mapClientStatus(raw) {
        const key = (raw || "").trim();

        // If there's truly nothing, treat as Not Started
        if (!key) return "Not Started";

        // If we already have a nice client-facing label from Retool,
        // just pass it through. These are the labels stageMap() sets.
        const passthrough = new Set([
          "Awaiting Client Documents",
          "Information Being Processed",
          "Information Not Started",
          "Preparation In Progress",
          "Preparation Not Started",
          "In Review",
          "Queued for Review",
          "Extension filed with IRS",
          "Extension accepted by IRS",
          "Tax return filed with IRS",
          "Tax return accepted by IRS",
          "Tax return ready for pickup",
          "Tax Return Complete"
        ]);

        if (passthrough.has(key)) {
          return key;
        }

        // Legacy/raw values that need to be normalized
        const table = {
          // Intake / waiting
          "Waiting on client": "Awaiting Client Documents",
          "Waiting on You": "Awaiting Client Documents",

          // Prep
          "Doing": "Preparation In Progress",
          "Preparation In Progress": "Preparation In Progress",

          // Review
          "Review in Progress": "Review In Progress",
          "In Review": "Review In Progress",

          // Extension / filing / accepted
          "Extension filed with IRS": "Extension filed with IRS",
          "Extension accepted by IRS": "Extension accepted by IRS",
          "Tax return filed with IRS": "Tax return filed with IRS",
          "Tax return accepted by IRS": "Tax return accepted by IRS",

          // Ready for pickup / complete
          "Tax return ready for pickup": "Tax return ready for pickup",
          "Tax Return Complete": "Tax Return Complete"
        };

        // If it's in the map, show the mapped label.
        // If it's NOT in the map and not one of the known labels,
        // treat as Not Started.
        return table[key] || "Not Started";
      }

      // ---------------------------
      // Status ranking: higher = further along
      // ---------------------------
      const STATUS_ORDER = {
        "Not Started": 0,
        "Awaiting Client Documents": 5,
        "Preparation In Progress": 10,
        "Preparation completed": 15,
        "Review In Progress": 20,
        "Extension filed with IRS": 25,
        "Extension accepted by IRS": 30,
        "Tax return filed with IRS": 40,
        "Tax return accepted by IRS": 45,
        "Tax return ready for pickup": 50,
        "Tax Return Complete": 55
      };

      // Statuses that temporarily UNLOCK going backwards
      const STATUS_UNLOCK_REGRESSION = new Set([
        "Extension filed with IRS",
        "Extension accepted by IRS"
      ]);

      function statusScore(status) {
        return STATUS_ORDER[status] ?? 0;
      }

      // ---------------------------------------------------
      // Enforce:
      //  - normally: status cannot go backwards (score never decreases)
      //  - while current status is EXTENSION FILED / ACCEPTED:
      //      allow any movement (for the next rows)
      //  - once status moves to something else, lock again
      // ---------------------------------------------------
      function enforceStatusWithExtensionWindow(rows) {
        const stateByKey = {};

        // Oldest → newest
        const sorted = rows
          .slice()
          .sort(
            (a, b) =>
              (Number(a.lastUpdatedIso) || 0) -
              (Number(b.lastUpdatedIso) || 0)
          );

        sorted.forEach((row) => {
          const key =
            row.clientName + "|" + row.taxYear + "|" + row.taxReturnType;

          let state = stateByKey[key];
          if (!state) {
            state = {
              lastScore: 0,
              lastLabel: null,
              allowRegression: false
            };
          }

          let status = row.status;
          let score = statusScore(status);
          const isExtension = STATUS_UNLOCK_REGRESSION.has(status);

          if (!state.allowRegression) {
            // "normal" mode: no going backwards
            if (score < state.lastScore) {
              // clamp to last label
              if (state.lastLabel) {
                row.status = state.lastLabel;
                status = state.lastLabel;
                score = statusScore(status);
              }
            } else {
              // moved forward or stayed same
              state.lastLabel = status;
              state.lastScore = score;
            }

            // entering extension window?
            if (STATUS_UNLOCK_REGRESSION.has(row.status)) {
              state.allowRegression = true;
            }
          } else {
            // extension window: allow movement in any direction
            state.lastLabel = status;
            state.lastScore = score;

            // if we leave extension statuses, close the window
            if (!STATUS_UNLOCK_REGRESSION.has(status)) {
              state.allowRegression = false;
            }
          }

          stateByKey[key] = state;
        });

        return rows;
      }

      // ---------------------------
      // Normalize tax year
      // ---------------------------
      function normalizeTaxYear(value) {
        if (!value) return "";
        if (/^\d{4}$/.test(value)) {
          return value;
        }
        const match = /^TY(\d{2})$/i.exec(value.trim());
        if (match) {
          const yy = Number(match[1]);
          const fullYear = yy < 50 ? 2000 + yy : 1900 + yy;
          return String(fullYear);
        }
        return value;
      }

      // ---------------------------
      // Format timestamp → "December 2nd, 2025"
      // Works with either ms or ISO string
      // ---------------------------
      function formatDate(value) {
        if (!value) return "";

        let d;
        const n = Number(value);
        if (!Number.isNaN(n) && n > 0) {
          d = new Date(n); // ms
        } else {
          d = new Date(value); // ISO
        }

        if (isNaN(d.getTime())) return "";

        const day = d.getDate();
        const suffix =
          day >= 11 && day <= 13
            ? "th"
            : ["st", "nd", "rd"][(day % 10) - 1] || "th";

        const month = d.toLocaleString("en-US", { month: "long" });
        const year = d.getFullYear();

        return `${month} ${day}${suffix}, ${year}`;
      }

      // ---------------------------
      // GLOBAL STATE FOR SORTING
      // ---------------------------
      var currentRows = [];
      var currentSort = {
        key: "taxYear",
        dir: "desc"
      };

      function getSortValue(row, key) {
        if (key === "taxYear") {
          return Number(row.taxYear) || 0;
        }
        if (key === "lastUpdatedIso") {
          return Number(row.lastUpdatedIso) || 0;
        }
        var v = row[key];
        if (v == null) return "";
        return String(v).toLowerCase();
      }

      function applySortAndRender() {
        var key = currentSort.key;
        var dir = currentSort.dir;
        var multiplier = dir === "asc" ? 1 : -1;

        var rows = currentRows.slice();
        rows.sort(function (a, b) {
          var va = getSortValue(a, key);
          var vb = getSortValue(b, key);

          if (va < vb) return -1 * multiplier;
          if (va > vb) return 1 * multiplier;
          return 0;
        });

        renderTable(rows);
      }

      // ---------------------------
      // Parse JSON rows from tickets param
      // ---------------------------
      function parseRows(rawString) {
        if (!rawString) return [];
        var rows;
        try {
          rows = JSON.parse(rawString);
        } catch (e) {
          console.error("Bad JSON for tax return status", e);
          showError("Failed to parse tax return status data.");
          return [];
        }

        var mapped = rows.map(function (r) {
          var rawYear = String(r.tax_year || "");
          var rawStatus = r.status_label || r.status || "";

          return {
            clientName: r.client_name || "",
            taxYear: normalizeTaxYear(rawYear),
            taxReturnType: r.tax_return_type || r.type || "",
            status: mapClientStatus(rawStatus),
            lastUpdatedIso: r.updated_iso || r.last_updated || ""
          };
        });

        // Apply extension-window logic
        enforceStatusWithExtensionWindow(mapped);

        return mapped;
      }

      // ---------------------------
      // Error display
      // ---------------------------
      function showError(message) {
        var el = document.getElementById("error");
        el.textContent = message;
        el.style.display = "block";
      }

      // ---------------------------
      // Render table rows
      // ---------------------------
      function renderTable(rows) {
        var tbody = document.getElementById("rows");
        tbody.innerHTML = "";

        if (!rows.length) {
          var tr = document.createElement("tr");
          var td = document.createElement("td");
          td.colSpan = 5;
          td.className = "empty";
          td.textContent = "No tax return status data available.";
          tr.appendChild(td);
          tbody.appendChild(tr);
          return;
        }

        rows.forEach(function (row) {
          var tr = document.createElement("tr");

          var tdClient = document.createElement("td");
          tdClient.className = "client";
          tdClient.textContent = row.clientName;
          tr.appendChild(tdClient);

          var tdYear = document.createElement("td");
          tdYear.textContent = row.taxYear;
          tr.appendChild(tdYear);

          var tdType = document.createElement("td");
          tdType.textContent = row.taxReturnType;
          tr.appendChild(tdType);

          var tdStatus = document.createElement("td");
          tdStatus.textContent = row.status;
          tr.appendChild(tdStatus);

          var tdUpdated = document.createElement("td");
          tdUpdated.textContent = formatDate(row.lastUpdatedIso);
          tr.appendChild(tdUpdated);

          tbody.appendChild(tr);
        });
      }

      // ---------------------------
      // Init
      // ---------------------------
      (function init() {
        try {
          var raw = getRawFromQuery();
          currentRows = parseRows(raw);

          // initial sort (taxYear desc)
          currentSort = { key: "taxYear", dir: "desc" };
          applySortAndRender();

          // Wire up header clicks
          var headers = document.querySelectorAll("th.sortable[data-sort]");
          headers.forEach(function (th) {
            th.addEventListener("click", function () {
              var key = th.getAttribute("data-sort");

              if (currentSort.key === key) {
                currentSort.dir =
                  currentSort.dir === "asc" ? "desc" : "asc";
              } else {
                currentSort.key = key;
                if (key === "taxYear" || key === "lastUpdatedIso") {
                  currentSort.dir = "desc";
                } else {
                  currentSort.dir = "asc";
                }
              }

              applySortAndRender();
            });
          });
        } catch (e) {
          console.error(e);
          showError("Failed to load tax return status data.");
        }
      })();
    </script>
  </body>
</html>
